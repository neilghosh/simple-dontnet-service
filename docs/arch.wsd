@startuml Simple DotNet Service Architecture

participant Client as C
participant "ASP.NET Core\nWeb API" as API
participant "IpController" as Controller
participant "IIpAddressService" as Service
participant "OutboundIpService" as ServiceImpl
participant "IIpifyProxy" as Proxy
participant "IpifyProxy" as ProxyImpl
participant "External API\n(api.ipify.org)" as ExtAPI

== HTTP Request: Get Outbound IP ==
C ->> API: GET /api/ip/outbound
activate API

API ->> Controller: Route to IpController
activate Controller

Controller ->> Service: GetOutboundIpAsync()
activate Service

Service ->> ServiceImpl: GetOutboundIpAsync()
activate ServiceImpl

ServiceImpl ->> Proxy: GetIpAsync()
activate Proxy

Proxy ->> ProxyImpl: GetIpAsync()
activate ProxyImpl

ProxyImpl ->> ExtAPI: HTTP GET
activate ExtAPI
ExtAPI -->> ProxyImpl: IP Address
deactivate ExtAPI

ProxyImpl -->> Proxy: IP Address
deactivate ProxyImpl

Proxy -->> ServiceImpl: IP Address
deactivate Proxy

ServiceImpl -->> Service: IP Address
deactivate ServiceImpl

Service -->> Controller: IP Address
deactivate Service

Controller -->> API: 200 OK
deactivate Controller

API -->> C: {"outboundip": "203.0.113.42"}
deactivate API

== HTTP Request: Get Inbound IP ==
C ->> API: GET /api/ip/inbound
activate API

API ->> Controller: Route to IpController
activate Controller

Controller ->> Controller: Get HttpContext.Connection.RemoteIpAddress
Controller -->> API: 200 OK
deactivate Controller

API -->> C: {"inboundip": "::1"}
deactivate API

== HTTP Request: Get Headers ==
C ->> API: GET /api/ip/headers
activate API

API ->> Controller: Route to IpController
activate Controller

Controller ->> Controller: Get HttpContext.Request.Headers
Controller -->> API: 200 OK
deactivate Controller

API -->> C: {"Host": "...", "User-Agent": "..."}
deactivate API

note over C
  Example Endpoints:
  GET /api/ip/outbound
  → {"outboundip":"203.0.113.42"}
  
  GET /api/ip/inbound
  → {"inboundip":"::1"}
  
  GET /api/ip/headers
  → {"Host":"localhost:5000",...}
end note

note over API
  Environment: Development/Production
  Port: 5000 (local), 8080 (Docker/ACI)
  Framework: .NET 8.0
  OpenAPI: Swagger/Swashbuckle
  
  Layers:
  - Controllers: IpController
  - Services: IIpAddressService, OutboundIpService
  - Proxies: IIpifyProxy, IpifyProxy
  - Tests: xUnit unit & integration tests
  
  Deployment:
  - Local: dotnet run
  - Docker: docker run
  - Azure: Container Instances (ACI)
end note

== CI/CD Deployment Flow ==
participant "GitHub Actions" as GHA
participant "Azure Container\nRegistry (ACR)" as ACR
participant "Azure Container\nInstances (ACI)" as ACI

note over GHA
  Trigger: Push to main or manual
  Steps:
  1. Build & Test .NET app
  2. Build Docker image
  3. Push to ACR
  4. Deploy to ACI
end note

GHA -> GHA: dotnet build & test
GHA -> ACR: docker push
GHA -> ACI: Deploy container
ACI -> ACR: Pull image
ACI -> ACI: Run container

note over ACI
  Serverless Container Hosting
  - Pay-per-second billing
  - Auto-scaling
  - Public IP with DNS
  - Port: 8080
  
  Cost Optimization:
  - Stop when not in use
  - No always-on charges
end note

@enduml