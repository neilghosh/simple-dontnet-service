@startuml Simple DotNet Service Architecture

participant "SPA Client\n(index.html)" as SPA
participant Client as C
participant "Azure AD\n(login.microsoftonline.com)" as AAD
participant "ASP.NET Core\nWeb API" as API
participant "Authentication\nMiddleware" as Auth
participant "IpController" as Controller
participant "UserController" as UserCtrl
participant "ConfigController" as ConfigCtrl
participant "IIpAddressService" as Service
participant "OutboundIpService" as ServiceImpl
participant "IIpifyProxy" as Proxy
participant "IpifyProxy" as ProxyImpl
participant "External API\n(api.ipify.org)" as ExtAPI

== OAuth 2.0 Authorization Code Flow with PKCE ==
SPA ->> SPA: Generate code_verifier & code_challenge
SPA ->> AAD: Redirect to /authorize\n(client_id, redirect_uri, code_challenge)
activate AAD
AAD ->> AAD: User signs in with Microsoft Account
AAD -->> SPA: Authorization code
deactivate AAD

SPA ->> AAD: POST /token\n(code, code_verifier)
activate AAD
AAD -->> SPA: access_token, id_token
deactivate AAD

== HTTP Request: Get User Claims (Protected) ==
SPA ->> API: GET /api/user/claims\nAuthorization: Bearer {access_token}
activate API

API ->> Auth: Validate JWT token
activate Auth
Auth ->> AAD: Verify token signature
Auth -->> API: Token valid, claims extracted
deactivate Auth

API ->> UserCtrl: Route to UserController
activate UserCtrl
UserCtrl ->> UserCtrl: Extract claims from User principal
UserCtrl -->> API: 200 OK
deactivate UserCtrl

API -->> SPA: {"isAuthenticated": true, "claims": {...}, "scopes": [...]}
deactivate API

== HTTP Request: Get Outbound IP (Public) ==
C ->> API: GET /api/ip/outbound
activate API

API ->> Controller: Route to IpController
activate Controller

Controller ->> Service: GetOutboundIpAsync()
activate Service

Service ->> ServiceImpl: GetOutboundIpAsync()
activate ServiceImpl

ServiceImpl ->> Proxy: GetIpAsync()
activate Proxy

Proxy ->> ProxyImpl: GetIpAsync()
activate ProxyImpl

ProxyImpl ->> ExtAPI: HTTP GET
activate ExtAPI
ExtAPI -->> ProxyImpl: IP Address
deactivate ExtAPI

ProxyImpl -->> Proxy: IP Address
deactivate ProxyImpl

Proxy -->> ServiceImpl: IP Address
deactivate Proxy

ServiceImpl -->> Service: IP Address
deactivate ServiceImpl

Service -->> Controller: IP Address
deactivate Service

Controller -->> API: 200 OK
deactivate Controller

API -->> C: {"outboundip": "203.0.113.42"}
deactivate API

== HTTP Request: Get Inbound IP ==
C ->> API: GET /api/ip/inbound
activate API

API ->> Controller: Route to IpController
activate Controller

Controller ->> Controller: Get HttpContext.Connection.RemoteIpAddress
Controller -->> API: 200 OK
deactivate Controller

API -->> C: {"inboundip": "::1"}
deactivate API

== HTTP Request: Get Headers ==
C ->> API: GET /api/ip/headers
activate API

API ->> Controller: Route to IpController
activate Controller

Controller ->> Controller: Get HttpContext.Request.Headers
Controller -->> API: 200 OK
deactivate Controller

API -->> C: {"Host": "...", "User-Agent": "..."}
deactivate API

note over SPA
  SPA Demo (wwwroot/index.html):
  - OAuth 2.0 PKCE flow (no MSAL.js)
  - Sign in with Microsoft Account
  - Display token claims & scopes
  - Call protected API endpoints
end note

note over C
  Example Endpoints:
  
  Public:
  GET /api/ip/outbound
  GET /api/ip/inbound
  GET /api/ip/headers
  GET /api/config
  
  Protected (requires Bearer token):
  GET /api/user/claims
end note

note over API
  Environment: Development/Production
  Port: 5000 (local), 8080 (Docker/ACI)
  Framework: .NET 8.0
  Authentication: Azure AD / JWT Bearer
  OpenAPI: Swagger with OAuth2 PKCE
  
  Layers:
  - Controllers: IpController, UserController, ConfigController
  - Services: IIpAddressService, OutboundIpService
  - Proxies: IIpifyProxy, IpifyProxy
  - Static Files: wwwroot/index.html (SPA)
  - Tests: xUnit unit & integration tests
  
  Deployment:
  - Local: dotnet run
  - Docker: docker run
  - Azure: Container Instances (ACI)
end note

== CI/CD Deployment Flow ==
participant "GitHub Actions" as GHA
participant "Azure Container\nRegistry (ACR)" as ACR
participant "Azure Container\nInstances (ACI)" as ACI

note over GHA
  Trigger: Push to main or manual
  Steps:
  1. Build & Test .NET app
  2. Build Docker image
  3. Push to ACR
  4. Deploy to ACI
end note

GHA -> GHA: dotnet build & test
GHA -> ACR: docker push
GHA -> ACI: Deploy container
ACI -> ACR: Pull image
ACI -> ACI: Run container

note over ACI
  Serverless Container Hosting
  - Pay-per-second billing
  - Auto-scaling
  - Public IP with DNS
  - Port: 8080
  
  Cost Optimization:
  - Stop when not in use
  - No always-on charges
end note

@enduml